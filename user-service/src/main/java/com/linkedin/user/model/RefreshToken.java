package com.linkedin.user.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * JPA Entity representing a refresh token for authentication.
 * 
 * Purpose:
 * Refresh tokens are long-lived tokens (7 days) used to obtain new access tokens
 * without requiring the user to re-enter their credentials.
 * 
 * Authentication Flow:
 * 1. User logs in → Get access token (15 min) + refresh token (7 days)
 * 2. Access token expires → Use refresh token to get new access token
 * 3. Refresh token expires → User must log in again
 * 4. User logs out → Delete refresh token (immediate revocation)
 * 
 * Security Features:
 * - Stored in database (can be revoked)
 * - One user can have multiple refresh tokens (multiple devices)
 * - Tokens are UUIDs (unguessable)
 * - Expiration date enforced
 * - Cascade delete when user is deleted
 * 
 * Database Table: refresh_tokens
 * Columns: id, token, user_id, expiry_date, created_at
 * Indexes: token (unique), user_id (for lookups)
 * 
 * Usage:
 * POST /api/auth/login → Creates refresh token
 * POST /api/auth/refresh → Validates and rotates refresh token
 * POST /api/auth/logout → Deletes refresh token
 */
@Entity
@Table(name = "refresh_tokens", indexes = {
    @Index(name = "idx_refresh_token", columnList = "token"),
    @Index(name = "idx_refresh_token_user_id", columnList = "user_id")
})
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RefreshToken {
    
    // ==================== Primary Key ====================
    
    /**
     * Unique identifier for the refresh token.
     * Auto-generated by database (BIGSERIAL in PostgreSQL).
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // ==================== Token Information ====================
    
    /**
     * The actual refresh token value (UUID).
     * Must be unique across all refresh tokens.
     * 
     * Example: "550e8400-e29b-41d4-a716-446655440000"
     * 
     * Security Note:
     * - This is NOT a JWT. It's a simple UUID stored in the database.
     * - Client sends this value in refresh requests.
     * - We look it up in database to validate.
     */
    @Column(name = "token", nullable = false, unique = true, length = 255)
    private String token;
    
    // ==================== User Association ====================
    
    /**
     * The user who owns this refresh token.
     * Many-to-One relationship: Many refresh tokens can belong to one user.
     * 
     * Why Many-to-One?
     * - User can have multiple devices (phone, laptop, tablet)
     * - Each device gets its own refresh token
     * - Logging out from one device doesn't log out all devices
     * 
     * Cascade:
     * - When user is deleted, all their refresh tokens are deleted (ON DELETE CASCADE)
     * 
     * Fetch Type:
     * - LAZY: User is only loaded when explicitly accessed (performance optimization)
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    // ==================== Expiration ====================
    
    /**
     * Expiration date and time for this refresh token.
     * After this time, the token is invalid and cannot be used.
     * 
     * Typical Duration: 7 days from creation
     * 
     * Validation:
     * - Before using token, check: expiryDate.isAfter(LocalDateTime.now())
     * - If expired, delete token and require login
     * 
     * Cleanup:
     * - Expired tokens should be periodically deleted (scheduled job)
     */
    @Column(name = "expiry_date", nullable = false)
    private LocalDateTime expiryDate;
    
    // ==================== Audit Fields ====================
    
    /**
     * Timestamp when this refresh token was created.
     * Used for tracking and cleanup.
     * 
     * Set automatically by database on INSERT.
     */
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    // ==================== Lifecycle Callbacks ====================
    
    /**
     * Set createdAt timestamp before persisting to database.
     * Called automatically by JPA before INSERT.
     */
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }
    
    // ==================== Helper Methods ====================
    
    /**
     * Check if this refresh token is expired.
     * 
     * @return true if token is expired (current time > expiry time)
     */
    public boolean isExpired() {
        return LocalDateTime.now().isAfter(this.expiryDate);
    }
    
    /**
     * Get the number of days until this token expires.
     * Returns 0 if already expired.
     * 
     * @return Days until expiration
     */
    public long getDaysUntilExpiry() {
        if (isExpired()) {
            return 0;
        }
        return java.time.temporal.ChronoUnit.DAYS.between(LocalDateTime.now(), this.expiryDate);
    }
    
    /**
     * Check if this token needs rotation (close to expiry).
     * Tokens should be rotated if they have less than 1 day left.
     * 
     * Token Rotation:
     * - When refresh token is used and close to expiry, issue a new one
     * - Delete the old token
     * - Ensures user doesn't get logged out if they're active
     * 
     * @return true if token should be rotated
     */
    public boolean needsRotation() {
        return getDaysUntilExpiry() < 1;
    }
    
    /**
     * String representation for logging (does NOT include token value for security).
     * 
     * @return String representation
     */
    @Override
    public String toString() {
        return "RefreshToken{" +
                "id=" + id +
                ", userId=" + (user != null ? user.getId() : null) +
                ", expiryDate=" + expiryDate +
                ", expired=" + isExpired() +
                ", createdAt=" + createdAt +
                '}';
    }
}

